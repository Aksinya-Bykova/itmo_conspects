# Базы данных

## Введение

Курс базы данных находится в цикле курсов "Управление данными" на направлении ИС

В отличие от математиков, перед которыми не стоят как таковые ограничения, у инженеров существуют ограничения, будь-то
бюджет или время. Поэтому инженеры вынуждены искать компромиссы между тремя главными параметрами: надежность,
производительность и безопасность.

В XX веке был сформулирован закон Мура, который прогнозировал увеличение числа транзисторов в два раза каждые два года,
но в 10-ых годах закон Мура перестал работать из-за физических ограничений. Далее появилось большое желание увеличивать
память, в следствие чего появились распределенные системы, но ограничениями
стала [теорема CAP](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP)

Британский учёный [Эдгар Кодд](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B4,_%D0%AD%D0%B4%D0%B3%D0%B0%D1%80) в
70-ых сформулировал основы теории **реляционных баз данных**, на основе которой созданы современные реляционные базы
данных

## Лекция 1

Выделяют 5 информационных процессов:

* Сбор
* Обработка
* Хранение
* Передача
* Представление

И эти процессы хотелось бы автоматизировать

До появления Computer Science как науки все эти процессы существовали в пределах небольших библиотеки, в которых книги
искались линейным или двоичным поисками. После этого библиотеки увеличивались, появились картотеки, каталоги.

Тем не менее определение информации так и не сформулировалось по многим философским вопросам: что такое информация?
Является ли информация атрибутом материи или энергии? Существует ли информация без человека? Поэтому информацию следует
воспринимать как триединство сигнала, данных и знаний.

В начале XX века Гёдель, целью которого была создать систему доказательств в математике, и, следовательно,
автоматизировать их, изобрел систему представления математических доказательств и доказал, что такая система не может
быть
полной ([теорема о неполноте](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D1%8B_%D0%93%D1%91%D0%B4%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B5))

После Гёделя появился Джон фон Нейман, целью которого была представить информацию в конечном пространстве. Из этой идеи
вывелась архитектура фон Неймана, где числа представлялись в двоичном виде. В итоге получается, что данные - это
информация, которая закодирована заранее обговоренным способом:

> **Данные** (ISO / IEC 2382:2015) - поддающееся многократной интерпретации представление информации в формализованном
> виде, пригодном для передачи, интерпретации или обработке

Из этого появляется потребность моделировать данные. Но у моделей появляются свои ограничения. Приведем пример таблицы
студентов:

| Студент | Группа | Дисциплина | Преподаватель | Аудитория | Время |
|---------|--------|------------|---------------|-----------|-------|
|         |        |            |               |           |       |
|         |        |            |               |           |       |

Поиск конкретного студента реализовать легко, но что если нам нужно иметь в виду несколько дисциплин для одного
студента? Приходит другая реализация:

| Студент | Группа | (Дисциплина1, ...) | (Дисциплина2, ...) |
|---------|--------|--------------------|--------------------|
|         |        |                    |                    |
|         |        |                    |                    |

Но в ней мы не сможем запросто составить расписание для какого-то преподавателя. Тогда приходит идея разделить на
несколько табличек для студентов:

| Номер студента | ФИО студента |
|----------------|--------------|
|                |              |

Для групп:

| Номер группы | Факультет группы |
|--------------|------------------|
|              |                  |

И для предметов:

| Номер дисциплины | Название дисциплины | Преподаватель |
|------------------|---------------------|---------------|
|                  |                     |               |

В этом случае повышается целостность данных, но уменьшается производительность системы, и в итоге мы не сможем найти
идеального решения
## Лекция 2

Откуда появилась идея абстрагирования данных? Сначала все началось с архитектуры фон Неймана, где появилась однородность памяти - концепция хранения данных и инструкций в одном месте. Потом появилась первая абстракция данных - хранение в файле. Если же в оперативной памяти читаемость не нужна, то в постоянной она необходима для упрощенной работы - будь-то имя файла и имя каталога. И так появляется файло-серверная архитектура:

![File-Server](images/databases_2024_09_12_1.png)

Все хорошо, но что, если приложений будет N? Каждое из них будет блокировать этот файл, таким образом можно соблюдать целостность данных, но файл становиться большим и нельзя поддерживать параллельный доступ (эффект конкурентных транзакций), падает производительность

Можно хранить несколько файлов, каждый из них хранящий группу данных (например: студенты, группы, факультеты), но все равно почти все запросы запрашивают те комбинации файлов, которые так или иначе пересекутся

Можно воспользоваться позиционированием - разбиением данных на группы (студентов на факультеты), но возникают другие проблемы: студенты мигрируют между факультетами, другие студенты ходят на занятия других факультетов

При этом данные растут, а если фрагментировать данные, то придется переписывать логику кода, что не является хорошей идеей. Да и к тому же возникает противоречие скоростей записи и чтения: нельзя обеспечить одинаково быстрые запись и чтение

В итоге появляется клиент-серверная архитектура, появляется СУБД (**Система Управления Базой Данных**) и моделирование данных, из-за чего мы избавляемся от привязанности к определенному формату файла

![Client-Server](images/databases_2024_09_12_2.png)

Появляется целостность данных, которая контролируется СУБД, и повышается производительность в следствие группировки запросов по времени и другим параметрам. Появляются правила моделирование бизнес-сущностей.

Но в чем состоит идея моделирования: выделение значимых аспектов у сущностей и для разных целей формирование различного моделирования

Выделяют 2 основания классификаций:

* Трехуровневая архитектура (ANSI/SPARC):
  - Внешний 
  - Концептуальный
  - Внутренний (физический, исходный)

_Внешний уровень_ определяет базу данных с точки зрения конечного пользователя, например: для студофиса важно знать возраст определенного студента, но хранить возраст не удобно

_Концептуальный уровень_ - на этом уровне накладываются ограничения на данные, определяются сущности и атрибуты, семантика данных (например: рейтинг компании на внешнем уровне может быть Excellent, Good, ..., а на концептуальном 5, 4, ... для упрощенной группировки)

_Внутренний уровень_ - то, что организует производительность, безопасность, структуру файлов, шифрование и ограниченный доступ к щекотливым данным

* И уровни моделей данных:
  - Сущность-связь
  - Логический (дата-логический) уровень
  - Физический уровень

Сущность-связь (ER, Entity-Relation) - абстрагирование объектов, появление связей

Логический уровень - то, как мы пытаемся описать сущность-связь, выделив какие-то формальные множества

Физический уровень - выбор СУБД на основе логического уровня (ограничения на типы данных, производительность, безопасность)

В конце концов появляется вот такой граф:

![Relations](images/databases_2024_09_12_3.png)

Сущность - множество экземпляров, реальных или абстрактных, однотипных объектов предметной области

Выделяют 2 типа сущности: сильная и слабая

Студент - сильная сущность, потому что может существовать без других

Группа - слабая сущность, потому что не может существовать без студентов (но группа может быть и сильной сущностью)

Также у сущностей могут быть атрибуты

- Составные, например, ФИО
- Простые, например, Фамилия и Имя по отдельности

А также:

- Однозначными - хранят одно значение, например, телефон
- Многозначными - хранят не меньше одного значения, например, контакт, хранящий JSON-объект с множеством телефонов

Появляются 3 вида связи:

* One-To-One: студент `-<>-` паспорт (1 `<->` 1) (паспорт можно выделить в отдельную сущность, чтобы ограничить к нему доступ)

* One-To-Many: группа `-<>-` студент (1 `<->` N)

* Many-To-Many: группы `-<>-` студенты (M `<->` N)

Получается такая картинка в нотации Чена:

![](images/databases_2024_09_12_4.png)


## Лекция 3

Прошлая лекция была про то, что моделировать данные надо с умом и с наделом на будущее, потому перестраивать модели и код будет очень дорого. Сейчас же приведем определение базы данных по нескольким разным источникам:

> 1) (по Коннолли и Беггу) База данных - совместно используемый набор логически связных данных и описание этих данных, предназначенный для удовлетворения информационных потребностей организаций

Здесь идет упор на то, что БД - это не только сами данные, но и их описание (схема, семантика), что подчеркивает целостность БД

> 2) (по Дейту) База данных - набор постоянно хранимых данных, используемых прикладными системами предприятия

В определении по Дейту подчеркивается то, что данные где-то физически хранятся на постоянной основе

> 3) (по Хомоненко) База данных - совокупность специальным образом организованных данных, хранимых в памяти вычислительной системы и отображающих состояние объектов и их взаимосвязей в рассматриваемой предметной области

Хомоненко объединяет другие определения и указывает, что базы данных могут использовать и не предприятиями

Эти же авторы приводят разные определения для Системы Управления Базой Данных (СУБД):

> 1) (по Коннолли, Беггу, Дейту) СУБД - ПО, с помощью которого пользователи могут определять, создавать и поддерживать базу данных, а также осуществлять контролируемый к ней доступ

> 2) (по Хомоненко) СУБД - комплекс языковых и программных средств, предназначенный для создания, ведения и совместного использования базы данных многими пользователями

Теперь рассмотрим несколько способ, каким образом моделировать данные:

**Иерархическая модель данных**

Идея в иерархической модели данных состоит в том, чтобы хранить данные в деревьях. В 60-70 годах вместо таблицы все данные представлялись в виде деревьев, например, на предприятиях продукт изготавливался из компонентов, которые делались из деталей, которые создавались из заготовок. Чаще всего деталей было относительно немного, поэтому иерархическая модель подходила лучше всего. В итоге появляются:

> Поле данных - атомарная (неделимая) единица данных

> Сегмент данных - совокупность полей данных

Пример: ФИО, название отдела, телефон - это **поля данных**, сотрудник с этими полями - **сегмент данных**, а Иванов Иван Иванович с отделе маркетинга с телефоном +7(777)777-77-77 - **экземпляр сегмента сотрудника**. Тут же введем отдел с названием и именем начальника. В конце концов появляется огромное дерево, в котором можно узнать информацию об отделе от конкретного сотрудника.

Тут появляются достоинства:

1) _Легкость проектирования_ - в принципе все в этом мире можно представить как дерево

И недостатки:

1) _Дублирование данных_ - пример: сотрудник числится в нескольких отделах, так как сотрудник не может иметь двух родителей-отделов, то придется создавать нового сотрудника-дублера - тратим память и нарушаем целостности

2) _Сложность поиска сверху вниз_ - мы не сможем быстро получить всех сотрудников конкретного отдела; в этом случае мы можем создать кучу полей `Сотрудник 1`, `Сотрудник 2`, `Сотрудник N`, но число N может быть меньшим, чем нам надо, в таком случае надо будет двигать всю память, чтобы добавить новое поле, либо большая часть этих полей будут не задействованы (такая же проблема в файловых системах ex3, ex4 - количество файлов в них строго ограничено)

> История из жизни:
>
> 4 курс, бакалавриат, девушка защищает диплом, решает выйти замуж и поменять фамилию. Приносит документы о смене, но базы данных разные, между ними период синхронизации. Данные об окончании образования отправляются в ФИС ГИА. Интеграция систем была раз в сутки, данные диплома из ФИС ГИА пришли со старой фамилией, а приложение к диплому печаталось с новой фамилией, но с тем же номером.


**Сетевая модель данных**

В сетевой модели мы разрешаем иметь у экземпляра сегмента нескольких родителей. В итоге получаем граф

Достоинства:

1) _Экономия памяти_

2) _Целостность_

Но мы можем присвоить каждому экземпляру идентификатор и хранить связи пар идентификаторов отдельно и данные отдельно

Недостатки:

1) _Обход графа медленный в больших графах_ - та же задача из иерархической модели, нам придется пройтись по всем сотрудникам, чтобы найти сотрудников конкретного отдела

Можно вспомнить пакетные менеджеры, где для загрузки зависимостей приложения строится граф зависимостей, который обходится, и менеджер принимает решение о загрузке пакетов.


**Реляционная модель данных**

Заметим, что большинство запросов очень однотипные: найти атрибуты конкретного сотрудника, агрегация сотрудников отдела; поэтому все наборы атрибутов можно хранить:

| ID сотрудника | ФИО | Телефон | ID отдела |
|---------------|-----|---------|-----------|
|               |     |         |           |

И для отделов:

| ID отдела | Название | ID начальника |
|-----------|----------|---------------|
|           |          |               |


И с точки зрения реляционной (сущность из таблицы образуют отношение эквивалентности (equivalency relation)) модели связей между таблицами нет - для СУБД ID отдела и ID сотрудника - это одинаковый вещи (например, в SQL возможна подобная конкатенация). Также в случае, если начальника уволили, а его ID отдали новому сотруднику, то возникнет ситуация, когда этот сотрудник будет восприниматься начальником

И тут возникает проблема с реляционной базой данных - она _плохо масштабируется_. Добавлять сотруднику еще один телефон - значит двигать всю память для выделения места под новый столбец

**Постреляционная модель данных**

В постреляционной модели мы снимаем ограничение на неделимость поля, тогда поле можно представить как структуру. 

Например, предприятие продает книги с атрибутами "жанр", "кол-во страниц", "год издания", но внезапно начинает продавать ручки с атрибутом "цвет". В реляционной БД, помимо универсальных атрибутов цены, штрих-кода, большинство полей остается избыточными - ручке не определишь жанр и кол-во страниц. 

Тогда можно хранить все индивидуальные атрибуты в структуре JSON или XML, сериализовать ее и хранить в бинарном виде. Но из-за этого появляются:

1) _Долгий поиск_ по второстепенным атрибутам

2) _Нарушение целостности_ - пример: компания, производящая ручки, сделала ребрендинг, теперь придется менять в каждой структуре бренд

**Многомерная модель данных**

Дается такая таблица фактов

| Товар | Сотрудник | Месяц | Количество проданных товаров |
|-------|-----------|-------|------------------------------|
| T1    | C1        | Янв   | 10                           |
| T2    | C1        | Янв   | 5                            |
| T3    | C3        | Фев   | 15                           |


И чтобы найти количество проданных товаров в марте, нужно пройтись по всей таблице. Тогда сделаем куб (многомерный массив), где оси - это значения товаров, сотрудников и месяцев, диапазоны значений которых фиксированы

Многомерные модели получаются очень разреженными, неэффективными по памяти (какой-то сотрудник может не продавать конкретный товар), но с очень быстрым доступом. Например: в течение дня приходят какие-то данные, ночью, когда трафик минимальный, модель перестраивается, и на следующий день можно составлять разнообразную аналитику


> Анекдот:
> 
> В 80-ых годах к профессору приходит студент: Знаете, вы блестящий преподаватель, но я все-таки решил отчислиться, поэтому хочу извиниться и проститься с вами.
>
> Но почему же вы сдаетесь? - спрашивает профессор.
> 
> Да я вот экзамен точно не сдам, - отвечает студент.
> 
> Ну почему же, голубчик?
> 
> Да вот вы каждую теорему в 9-мерном пространстве доказываете, я ничего из этого не понимаю.
>
> Хорошо, я вам еще один раз объясню, что 9-мерное пространство - это очень легко. Вот представьте обыкновенное n-мерное пространство, а потом возьмите n = 9.



**Объектно-ориентированная модель данных**

Вспомним, что объект - совокупность полей. Тогда появились ORM-модели (Object Relation Model) - создается таблица с атрибутами класса, объект записывается как строка в таблицу.

В этом случае целостность данных гарантируется тем, что данные изменяются только методами объекта, Но если изменить данные в табличке, в файле, получим нецелостный объект

Можно хранить в объекте вместо данных ключ, который ссылается на данные в бинарном файле, а в методах объекта данные сразу же записываются в файл

<hr>

В конечном итоге большинство современных СУБД являются многопарадигмиальными - как компромисс в противоречии между целостностью, выборкой данных и записи данных. Но на данный момент реляционная модель является наиболее оптимальной из-за ее производительности и гарантии целостности данных

